---
layout: post
title:  Typestate-oriented programming in F\*
date:   2016-03-18
categories: fstar typestate
---

Going to transfer examples from the paper [Typestate-oriented programming](http://www.cs.cmu.edu/~aldrich/papers/onward2009-state.pdf) to F\*.

F\* is a new programming language with dependent types and incremental proving.


    state File {
      public final String filename;
    }

    state OpenFile extends File {
      private CFilePtr filePtr;
      public int read() { ... }
      public void close() [OpenFile>>ClosedFile] { ... }
    }

    state ClosedFile extends File {
      public void open() [ClosedFile>>OpenFile] { ... }
    }

The intuition behind this. When the file object changes state, it also changes its interface. That way, you can't accidentally read from a closed file.

And the imperative program:

    int readFromFile(ClosedFile f) {
      openHelper(f);
      int x = computeBase() + f.read();
      f.close();
      return x;
    }

We can loosely immitate this code in OCaml:

(I choose OCaml since F\* can be extracted to either F# or OCaml.)

    let open_helper filename =
        open_in filename

    let read channel =
        let line = input_line channel in
        int_of_string line

    let compute_base () =
        12

    let read_from_file filename =
        let file = open_helper filename in
        let x = compute_base () + read file in
        close_in file;
        x

    let _ =
        print_int (read_from_file "file.txt")  (* <--- Prints e.g. 13 *)

Problems:

* How do we know that `open_helper` returns an open channel?
* How can we limit `read` to only accept an open channel?
* How do we know that `read` isn't also closing the channel?
* How can we make sure that the channel is closed before the program ends?

Our first try will use refined types but no state. We will solve a couple of aforementioned problems but not all of them.

To solve the other problems, we have to dig into F\*'s heap system.

    module Typestate2

    open FStar.Heap
    open FStar.ST

    type state =
      | Open
      | Closed

    type file = {name: string; state: ref state}

    type isClosed file heap = (sel heap file.state) == Closed
    type isOpen file heap = (sel heap file.state) == Open

    val openHelper : file:file -> ST unit
        (requires (isClosed file))
        (ensures (fun heap s heap' ->
            isOpen file heap'
            ))
    let openHelper file =
        file.state := Open

    let computeBase () =
        12

    val read : file:file -> ST int
        (requires (isOpen file))
        (ensures (fun heap s heap' -> isOpen file heap'))
    let read file =
        13

    val readFromFile : file:file -> ST unit
        (requires (isClosed file))
        (ensures (fun heap s heap' -> isClosed file heap'))
    let readFromFile file =
        openHelper file;
        let x = computeBase () + read file in
        file.state := Closed

    let nil =
        let file1 = {
            name = "file1";
            state = alloc Closed;
        } in
        readFromFile file1
